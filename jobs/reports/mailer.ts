//
// Copyright (c) Microsoft.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.
//

/* eslint no-console: ["error", { allow: ["warn", "dir", "log"] }] */

// There is an edge case for losing reports - if someone has an e-mail addresses added to a service
// account, and also is linked themselves, then it's possible that they may get multiple reports or
// may have the reports masked.

const fs = require('fs');
const path = require('path');
const pug = require('pug');

import { IReportsContext } from './task';
import { IMailProvider } from '../../lib/mailProvider';

import emailRender from '../../lib/emailRender';
import { writeTextToFile } from '../../utils';

interface IReportRenderOptions {
  to: string;
  github: {
    consolidated: any;
  }
  pretty?: boolean;
  basedir?: string;
  viewServices: any;
}

export default async function sendReports(context: IReportsContext): Promise<IReportsContext> {
  const mailProvider = context.operations.providers.mailProvider;
  if (!mailProvider) {
    throw new Error('No mailProvider is available to send messages');
  }
  const reportsByRecipient = context.reportsByRecipient;
  if (!reportsByRecipient) {
    throw new Error('No consolidated reports were generated by recipient');
  }
  const overrideSendWithPath = context.settings.fakeSend;
  if (overrideSendWithPath) {
    console.warn(`Instead of sending mail, mail will be written to ${overrideSendWithPath}`);
    try {
      fs.mkdirSync(overrideSendWithPath);
    } catch (ignored) {
      console.log(`While creating directory to store e-mails instead of sending, received: ${ignored.message}`);
    }
  }
  const recipients = Array.from(reportsByRecipient.keys());
  for (const recipientKey of recipients) {
    try {
      await sendReport(context, mailProvider, reportsByRecipient, recipientKey);
    } catch (sendMailError) {
      console.dir(sendMailError);
    }
  }
  return context;
}

function resolveAddress(context: IReportsContext, upn: string): Promise<string> {
  const operations = context.operations;
  const providers = operations.providers;
  if (!providers.mailAddressProvider) {
    return Promise.reject(new Error('No mailAddressProvider is available in this application instance'));
  }
  return new Promise((resolve, reject) => {
    providers.mailAddressProvider.getAddressFromUpn(upn, (error, address) => {
      return error ? reject(error) : resolve(address);
    });
  });
}

function recipientTypeToAddress(context: IReportsContext, address: string): Promise<string> {
  const i = address.indexOf(':');
  if (i < 0) {
    return Promise.reject(new Error('Invalid consolidated address format'));
  }
  const type = address.substr(0, i);
  const remainder = address.substr(i + 1);
  if (type === 'mail') {
    return Promise.resolve(remainder);
  } else if (type === 'upn') {
    return resolveAddress(context, remainder);
  } else {
    return Promise.reject(new Error(`Unsupported consolidated address type ${type}`));
  }
}

function consolidatedActionRequired(report) {
  for (let i = 0; i < report.length; i++) {
    const definition = report[i].definition;
    if (definition.isActionRequired) {
      return true;
    }
  }
  return false;
}

function renderReport(context, report, address) {
  const options: IReportRenderOptions = {
    github: {
      consolidated: report,
    },
    viewServices: context.operations.providers.viewServices,
    to: address,
  };
  const basedir = path.join(__dirname, 'views');
  const view = path.join(basedir, 'administrator.pug');
  options.pretty = true;
  options.basedir = basedir;
  let html = null;
  try {
    html = pug.renderFile(view, options);
  } catch (renderingProblem) {
    console.warn(renderingProblem);
    throw renderingProblem;
  }
  return html;
}

async function sendReport(context: IReportsContext, mailProvider: IMailProvider, reportsByRecipient, recipientKey: string): Promise<IReportsContext> {
  const report = reportsByRecipient.get(recipientKey);
  const overrideSendWithPath = context.settings.fakeSend;
  const fromAddress = context.settings.fromAddress;
  if (!fromAddress && !overrideSendWithPath) {
    throw new Error('No from address is configured for reports in the github.jobs.reports.mail.from value');
  }
  const address = await recipientTypeToAddress(context, recipientKey);
  if (!report || !report.length) {
    return context;
  }
  const isActionRequired = consolidatedActionRequired(report);
  const notification = isActionRequired ? 'action' : 'information';
  const html = renderReport(context, report, address);
  const viewOptions = {
    html: html,
    headline: isActionRequired ? 'Your GitHub updates' : 'GitHub updates',
    app: 'Microsoft GitHub',
    reason: 'This digest report is provided to all managed GitHub organization owners, repository admins, and team maintainers. This report was personalized and sent directly to ' + address,
    notification: notification,
  };
  const basedir = context.settings.basedir;
  const mailContent = await emailRender(basedir, 'report', viewOptions);
  // Store the e-mail instead of sending
  if (overrideSendWithPath) {
    const filename = path.join(overrideSendWithPath, `${address}.html`);
    await writeTextToFile(filename, mailContent);
    return context;
  }
  // Send the e-mail
  const actionSubject = isActionRequired ? 'Action required: ' : '';
  const mailOptions = {
    to: address,
    from: fromAddress,
    subject: `${actionSubject}GitHub digest for ${address}`,
    content: mailContent,
    category: ['report', 'repos'],
  };
  let mailResult = null;
  let mailError = null;
  try {
    mailResult = await mailProvider.sendMail(mailOptions);
  } catch (mailErrorThrown) {
    mailError = mailErrorThrown;
  }
  const customData = {
    receipt: mailResult,
    eventName: mailError ? 'JobReportSendFailed' : 'JobReportSendSuccess'
  };
  if (mailError) {
    context.insights.trackException({
      exception: mailError,
      properties: customData,
    });
    throw mailError;
  } else {
    context.insights.trackEvent({
      name: 'JobMailProviderReportSent',
      properties: customData,
    });
  }
  return context;
}
